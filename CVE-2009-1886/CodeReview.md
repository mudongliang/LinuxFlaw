首先，CVE-2009-1886 smbclient format string 这个漏洞的出现在 client/client.c 这个文件中的多个函数中，例如 cmd_put, cmd_get, do_cd等。  
由于exploit给出来的命令例子都是put aa%3Fbb,所以我也就根据这个直接去看cmd_put这个函数。下面给出来漏洞所在位置：

    client/client.c
    
    if (!next_token_talloc(ctx, &cmd_ptr,&lname,NULL)) {
        d_printf("put <filename>\n");
        return 1;
    }

**Comment**: 这部分代码时测试lname这个变量，也就是用户提供的文件名是否为空，如果是空的话，提示用户输入文件名。

    if (next_token_talloc(ctx, &cmd_ptr,&buf,NULL)) {
        rname = talloc_asprintf_append(rname, buf);
    } else {
        rname = talloc_asprintf_append(rname, lname);
    }

**Comment**: 这部分代码的功能是判断buf变量是否为空，如果为不为空，直接从buf拷贝到rname，这个函数的实现在下面会说，我们可以直接理解为sprintf这个函数的功能。

    sprintf 函数
    原型
    int sprintf( char *buffer, const char *format, [ argument] … );
    参数列表
    
    buffer：char型指针，指向将要写入的字符串的缓冲区。
    format：格式化字符串。
    [argument]...：可选参数，可以是任何类型的数据。
    返回值：字符串长度（strlen）

由于这里直接使用将lname这个用户输入的文件名当做了format这个变量也就是format string来使用。当format这个格式化字符创中没有所谓的“format specifier”的时候，没有问题，一旦有的话，这个函数就会读取栈上面的值，就会出现 information leak 。

    lib/talloc/talloc.c

    /*
     Realloc @p s to append the formatted result of @p fmt and return @p
     s, which may have moved.  Good for gradually accumulating output
     into a string buffer.
     */
    char *talloc_asprintf_append(char *s, const char *fmt, ...)
    {
        va_list ap;

        va_start(ap, fmt);
        s = talloc_vasprintf_append(s, fmt, ap);
        va_end(ap);
        return s;
    }

**Comment**: 之所以把这个函数的内容拿出来给大家看一下，其实只需要函数原型，大家就可以明白这个问题了。lname在这个函数里面被当做format string来使用了！

分析到最后，有很多samba的命令都使用了这个有缺陷的函数，所以他们都有这样的format string漏洞。
为了分析这几个漏洞之间的关系，我们可以如果操作这些命令的主函数，或许我会有些别的感觉。

main -> process_command_string -> 通过commands数组name变量的比对，找到正确的命令对应的函数 -> 执行对应的函数即可

    /* This defines the commands supported by this client.
     * NOTE: The "!" must be the last one in the list because it's fn pointer
     *       field is NULL, and NULL in that field is used in process_tok()
     *       (below) to indicate the end of the list.  crh
     */
    static struct {
        const char *name;
        int (*fn)(void);
        const char *description;
        char compl_args[2];      /* Completion argument info */
    } commands[] = {
        {"del",cmd_del,"<mask> delete all matching files",{COMPL_REMOTE,COMPL_NONE}},
        {"ls",cmd_dir,"<mask> list the contents of the current directory",{COMPL_REMOTE,COMPL_NONE}},
        {"put",cmd_put,"<local name> [remote name] put a file",{COMPL_LOCAL,COMPL_REMOTE}},
        ......
    }；

而调用对应的函数使用的是如下的代码，

    rc = commands[i].fn();

最后，我们给一下cmd_put缺陷代码的patch，

    if (next_token_talloc(ctx, &cmd_ptr,&buf,NULL)) {
    -		rname = talloc_asprintf_append(rname, buf);
    +		rname = talloc_asprintf_append(rname, "%s", buf);
    } else {
    -		rname = talloc_asprintf_append(rname, lname);
    +		rname = talloc_asprintf_append(rname, "%s", lname);
    }

